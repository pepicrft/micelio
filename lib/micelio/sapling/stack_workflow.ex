defmodule Micelio.Sapling.StackWorkflow do
  @moduledoc """
  Simulates stacked agent sessions in Git/Sapling repositories and records the workflow output.
  """

  @type tool :: :git | :sapling

  @default_tools [:git, :sapling]
  @default_sessions 3

  @spec parse_tools(nil | String.t() | [tool()]) :: {:ok, [tool()]} | {:error, term()}
  def parse_tools(nil), do: {:ok, @default_tools}

  def parse_tools(tools) when is_list(tools) do
    normalized =
      tools
      |> Enum.map(&normalize_tool/1)
      |> Enum.reject(&is_nil/1)

    if length(normalized) == length(tools) and normalized != [] do
      {:ok, normalized}
    else
      {:error, {:unknown_tools, tools}}
    end
  end

  def parse_tools(tools) when is_binary(tools) do
    tools
    |> String.split(",", trim: true)
    |> Enum.map(&String.trim/1)
    |> Enum.reject(&(&1 == ""))
    |> Enum.map(&normalize_tool/1)
    |> case do
      [] ->
        {:error, {:unknown_tools, tools}}

      normalized ->
        if Enum.any?(normalized, &is_nil/1) do
          {:error, {:unknown_tools, tools}}
        else
          {:ok, normalized}
        end
    end
  end

  @spec ensure_tools([tool()], keyword()) :: :ok | {:error, term()}
  def ensure_tools(tools, opts \\ []) do
    availability = tool_availability(tools, opts)

    case availability.missing do
      [] -> :ok
      _ -> {:error, {:missing_tools, availability.missing}}
    end
  end

  @spec tool_availability([tool()], keyword()) :: %{available: [tool()], missing: [tool()]}
  def tool_availability(tools, opts \\ []) do
    finder = Keyword.get(opts, :finder, &System.find_executable/1)

    {available, missing} =
      Enum.split_with(tools, fn tool ->
        tool
        |> tool_command()
        |> finder.()
      end)

    %{available: available, missing: missing}
  end

  @spec run(keyword()) :: {:ok, map()}
  def run(opts \\ []) do
    tools = Keyword.get(opts, :tools, @default_tools)
    sessions = Keyword.get(opts, :sessions, @default_sessions)
    runner = Keyword.get(opts, :runner, &System.cmd/3)
    fs = Keyword.get(opts, :fs, File)
    tmp_root = Keyword.get(opts, :tmp_root, System.tmp_dir!())
    cleanup = Keyword.get(opts, :cleanup, true)
    finder = Keyword.get(opts, :finder, &System.find_executable/1)

    started_at = DateTime.utc_now()
    availability = tool_availability(tools, finder: finder)

    results =
      Enum.map(availability.available, fn tool ->
        run_tool(tool, sessions, tmp_root, runner, fs, cleanup)
      end)

    {:ok,
     %{
       tools: tools,
       available_tools: availability.available,
       missing_tools: availability.missing,
       sessions: sessions,
       started_at: started_at,
       results: results
     }}
  end

  @spec format_markdown(map()) :: String.t()
  def format_markdown(report) do
    tools = Map.get(report, :tools, [])
    available_tools = Map.get(report, :available_tools, [])
    missing_tools = Map.get(report, :missing_tools, [])
    sessions = Map.get(report, :sessions, @default_sessions)
    started_at = Map.get(report, :started_at, DateTime.utc_now())

    header =
      [
        "# Sapling stacking workflow report",
        "",
        "This report is generated by `mix micelio.sapling.stack_workflow`.",
        "",
        "Sessions simulated: #{sessions}",
        "Started at: #{DateTime.to_iso8601(started_at)}"
      ]
      |> Kernel.++([
        "",
        "Tools requested: `#{Enum.join(tools, ", ")}`",
        "Available tools: `#{Enum.join(available_tools, ", ")}`"
      ])
      |> Kernel.++(missing_tools_line(missing_tools))
      |> Kernel.++([
        "",
        "## Workflow",
        "",
        "- Initialize a repo per tool",
        "- Create a base commit",
        "- Create #{sessions} agent session commits (stacked branches for Git)",
        "- Capture stack/log views"
      ])

    results =
      report
      |> Map.get(:results, [])
      |> Enum.flat_map(&format_tool_result/1)

    (header ++ ["", "## Results", ""] ++ results ++ [""])
    |> Enum.join("\n")
  end

  defp missing_tools_line([]), do: []

  defp missing_tools_line(missing_tools) do
    ["Missing tools: `#{Enum.join(missing_tools, ", ")}`"]
  end

  defp format_tool_result(%{tool: tool, repo_path: repo_path, status: status, steps: steps}) do
    [
      "### #{tool}",
      "Repo path: `#{repo_path}`",
      "Status: #{status}",
      ""
    ] ++ format_steps(steps) ++ [""]
  end

  defp format_steps([]), do: ["(no steps recorded)"]

  defp format_steps(steps) do
    Enum.flat_map(steps, fn step ->
      command = "#{step.command} #{Enum.join(step.args, " ")}"
      output = format_output(step.output)

      [
        "#{step.label}: `#{command}` (status #{step.status})",
        "Output:",
        "```",
        output,
        "```",
        ""
      ]
    end)
  end

  defp format_output(output) do
    output
    |> to_string()
    |> String.trim_trailing()
    |> case do
      "" -> "(no output)"
      value -> value
    end
  end

  defp run_tool(tool, sessions, tmp_root, runner, fs, cleanup) do
    repo_path = Path.join(tmp_root, "sapling_stack_workflow_#{tool}_#{System.unique_integer([:positive])}")

    fs.mkdir_p!(repo_path)

    env = tool_env(tool)

    {steps, status} =
      {[], :ok}
      |> run_step(:init_repo, tool_command(tool), ["init"], repo_path, env, runner)
      |> run_step(:configure_identity, tool_command(tool), identity_args(tool), repo_path, env, runner)
      |> create_base_commit(tool, repo_path, env, runner, fs)
      |> create_session_commits(tool, sessions, repo_path, env, runner, fs)
      |> run_step(:stack_view, tool_command(tool), stack_view_args(tool), repo_path, env, runner)
      |> run_step(:log_view, tool_command(tool), log_view_args(tool), repo_path, env, runner)

    if cleanup do
      fs.rm_rf!(repo_path)
    end

    %{
      tool: tool,
      repo_path: repo_path,
      status: status,
      steps: steps
    }
  end

  defp create_base_commit({steps, :error}, _tool, _repo_path, _env, _runner, _fs), do: {steps, :error}

  defp create_base_commit({steps, :ok}, tool, repo_path, env, runner, fs) do
    fs.write!(Path.join(repo_path, "README.md"), "# Stacked Workflow\n\nBase commit.\n")

    {steps, :ok}
    |> run_step(:stage_base, tool_command(tool), add_args(tool), repo_path, env, runner)
    |> run_step(:commit_base, tool_command(tool), commit_args(tool, "base: initialize repo"), repo_path, env, runner)
  end

  defp create_session_commits({steps, :error}, _tool, _sessions, _repo_path, _env, _runner, _fs),
    do: {steps, :error}

  defp create_session_commits({steps, :ok}, tool, sessions, repo_path, env, runner, fs) do
    1..sessions
    |> Enum.reduce({steps, :ok}, fn session, acc ->
      {current_steps, current_status} = acc

      if current_status == :error do
        acc
      else
        branch_name = "agent/stack-#{session}"

        {current_steps, :ok}
        |> maybe_create_branch(tool, branch_name, repo_path, env, runner)
        |> write_session_file(repo_path, session, fs)
        |> run_step(:stage_session, tool_command(tool), add_args(tool), repo_path, env, runner)
        |> run_step(
          :commit_session,
          tool_command(tool),
          commit_args(tool, "agent/session-#{session}: update"),
          repo_path,
          env,
          runner
        )
      end
    end)
  end

  defp maybe_create_branch({steps, :error}, _tool, _branch_name, _repo_path, _env, _runner), do: {steps, :error}

  defp maybe_create_branch({steps, :ok}, :git, branch_name, repo_path, env, runner) do
    run_step({steps, :ok}, :checkout_branch, "git", ["checkout", "-b", branch_name], repo_path, env, runner)
  end

  defp maybe_create_branch({steps, :ok}, :sapling, _branch_name, _repo_path, _env, _runner), do: {steps, :ok}

  defp write_session_file({steps, :error}, _repo_path, _session, _fs), do: {steps, :error}

  defp write_session_file({steps, :ok}, repo_path, session, fs) do
    notes_dir = Path.join(repo_path, "notes")
    fs.mkdir_p!(notes_dir)

    fs.write!(
      Path.join(notes_dir, "session_#{session}.md"),
      "Session #{session}\n\nSimulated agent change.\n"
    )

    {steps, :ok}
  end

  defp run_step({steps, :error}, _label, _cmd, _args, _repo_path, _env, _runner), do: {steps, :error}

  defp run_step({steps, :ok}, label, cmd, args, repo_path, env, runner) do
    {output, status} =
      runner.(cmd, args, command_opts(repo_path, env))

    step = %{
      label: label,
      command: cmd,
      args: args,
      status: status,
      output: to_string(output)
    }

    next_status = if status == 0, do: :ok, else: :error
    {steps ++ [step], next_status}
  end

  defp command_opts(repo_path, []), do: [cd: repo_path]
  defp command_opts(repo_path, env), do: [cd: repo_path, env: env]

  defp normalize_tool(:git), do: :git
  defp normalize_tool(:sapling), do: :sapling
  defp normalize_tool("git"), do: :git
  defp normalize_tool("sapling"), do: :sapling
  defp normalize_tool("sl"), do: :sapling
  defp normalize_tool(_), do: nil

  defp tool_command(:git), do: "git"
  defp tool_command(:sapling), do: "sl"

  defp tool_env(:git) do
    [
      {"GIT_AUTHOR_NAME", "Micelio Agent"},
      {"GIT_AUTHOR_EMAIL", "agent@micelio.dev"},
      {"GIT_COMMITTER_NAME", "Micelio Agent"},
      {"GIT_COMMITTER_EMAIL", "agent@micelio.dev"}
    ]
  end

  defp tool_env(:sapling) do
    [{"HGUSER", "Micelio Agent <agent@micelio.dev>"}]
  end

  defp identity_args(:git), do: ["config", "user.name", "Micelio Agent"]
  defp identity_args(:sapling), do: ["config", "ui.username", "Micelio Agent <agent@micelio.dev>"]

  defp add_args(:git), do: ["add", "-A"]
  defp add_args(:sapling), do: ["add", "."]

  defp commit_args(:git, message), do: ["commit", "-m", message]
  defp commit_args(:sapling, message), do: ["commit", "-m", message]

  defp stack_view_args(:git), do: ["log", "--graph", "--oneline", "--decorate", "--all", "-n", "20"]
  defp stack_view_args(:sapling), do: ["stack"]

  defp log_view_args(:git), do: ["show-branch", "--more=5"]
  defp log_view_args(:sapling), do: ["log", "-l", "20"]
end
