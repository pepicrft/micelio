defmodule Micelio.Sapling.Interoperability do
  @moduledoc """
  Evaluates Sapling and Git interoperability for gradual migration.
  """

  @type tool :: :git | :sapling

  @default_tools [:git, :sapling]

  @spec parse_tools(nil | String.t() | [tool()]) :: {:ok, [tool()]} | {:error, term()}
  def parse_tools(nil), do: {:ok, @default_tools}

  def parse_tools(tools) when is_list(tools) do
    normalized =
      tools
      |> Enum.map(&normalize_tool/1)
      |> Enum.reject(&is_nil/1)

    if length(normalized) == length(tools) and normalized != [] do
      {:ok, normalized}
    else
      {:error, {:unknown_tools, tools}}
    end
  end

  def parse_tools(tools) when is_binary(tools) do
    tools
    |> String.split(",", trim: true)
    |> Enum.map(&String.trim/1)
    |> Enum.reject(&(&1 == ""))
    |> Enum.map(&normalize_tool/1)
    |> case do
      [] ->
        {:error, {:unknown_tools, tools}}

      normalized ->
        if Enum.any?(normalized, &is_nil/1) do
          {:error, {:unknown_tools, tools}}
        else
          {:ok, normalized}
        end
    end
  end

  @spec tool_availability([tool()], keyword()) :: %{available: [tool()], missing: [tool()]}
  def tool_availability(tools, opts \\ []) do
    finder = Keyword.get(opts, :finder, &System.find_executable/1)

    {available, missing} =
      Enum.split_with(tools, fn tool ->
        tool
        |> tool_command()
        |> finder.()
      end)

    %{available: available, missing: missing}
  end

  @spec tool_versions([tool()], keyword()) :: %{tool() => String.t()}
  def tool_versions(tools, opts \\ []) do
    runner = Keyword.get(opts, :runner, &System.cmd/3)

    tools
    |> Enum.map(fn tool ->
      {output, status} = runner.(tool_command(tool), ["--version"], [])

      version =
        output
        |> to_string()
        |> String.trim()
        |> case do
          "" -> "unknown"
          value -> value
        end

      version = if status == 0, do: version, else: "unknown"

      {tool, version}
    end)
    |> Map.new()
  end

  @spec run(keyword()) :: {:ok, map()}
  def run(opts \\ []) do
    tools = Keyword.get(opts, :tools, @default_tools)
    runner = Keyword.get(opts, :runner, &System.cmd/3)
    fs = Keyword.get(opts, :fs, File)
    tmp_root = Keyword.get(opts, :tmp_root, System.tmp_dir!())
    cleanup = Keyword.get(opts, :cleanup, true)
    finder = Keyword.get(opts, :finder, &System.find_executable/1)

    started_at = DateTime.utc_now()
    availability = tool_availability(tools, finder: finder)
    requested = MapSet.new(tools)
    available = MapSet.new(availability.available)
    tool_versions = tool_versions(availability.available, runner: runner)

    {git_result, git_repo_path} =
      run_git_repo(requested, available, tmp_root, runner, fs)

    {sapling_result, sapling_repo_path} =
      run_sapling_repo(requested, available, tmp_root, runner, fs)

    if cleanup do
      [git_repo_path, sapling_repo_path]
      |> Enum.reject(&is_nil/1)
      |> Enum.each(&fs.rm_rf!/1)
    end

    {:ok,
     %{
       tools: tools,
       available_tools: availability.available,
       missing_tools: availability.missing,
       tool_versions: tool_versions,
       started_at: started_at,
       results: [git_result, sapling_result]
     }}
  end

  @spec format_markdown(map()) :: String.t()
  def format_markdown(report) do
    tools = Map.get(report, :tools, [])
    available_tools = Map.get(report, :available_tools, [])
    missing_tools = Map.get(report, :missing_tools, [])
    tool_versions = Map.get(report, :tool_versions, %{})
    started_at = Map.get(report, :started_at, DateTime.utc_now())
    results = Map.get(report, :results, [])

    tool_lines =
      cond do
        tool_versions != %{} ->
          Enum.map(tool_versions, fn {tool, version} -> "- #{tool}: #{version}" end)

        available_tools != [] ->
          Enum.map(available_tools, fn tool -> "- #{tool}: (version not captured)" end)

        true ->
          ["- (not captured)"]
      end

    header =
      [
        "# Sapling Git interoperability report",
        "",
        "This report is generated by `mix micelio.sapling.interoperability`.",
        "",
        "Started at: #{DateTime.to_iso8601(started_at)}",
        "",
        "Tools requested: `#{Enum.join(tools, ", ")}`",
        "Available tools: `#{Enum.join(available_tools, ", ")}`"
      ]
      |> Kernel.++(missing_tools_line(missing_tools))
      |> Kernel.++([
        "",
        "## Tool versions",
        "",
        Enum.join(tool_lines, "\n"),
        "",
        "## Summary",
        "",
        Enum.join(summary_lines(results), "\n"),
        "",
        "## Scenarios",
        "",
        Enum.join(scenario_lines(), "\n"),
        "",
        "## Results",
        ""
      ])

    results = Enum.flat_map(results, &format_scenario/1)

    (header ++ results ++ [""])
    |> Enum.join("\n")
  end

  defp run_git_repo(requested, available, tmp_root, runner, fs) do
    repo_path = Path.join(tmp_root, "sapling_interop_git_#{System.unique_integer([:positive])}")

    requested_git = MapSet.member?(requested, :git)
    available_git = MapSet.member?(available, :git)

    {steps, git_status} =
      cond do
        not requested_git ->
          {skip_steps_for_git_repo([], "tool not requested: git"), :skipped}

        not available_git ->
          {skip_steps_for_git_repo([], "missing tool: git"), :skipped}

        true ->
          fs.mkdir_p!(repo_path)
          env = tool_env(:git)

          {[], :ok}
          |> run_step(:git_init, tool_command(:git), ["init"], repo_path, env, runner)
          |> run_step(:git_config, tool_command(:git), identity_args(:git), repo_path, env, runner)
          |> write_readme(repo_path, fs)
          |> run_step(:git_add, tool_command(:git), add_args(:git), repo_path, env, runner)
          |> run_step(:git_commit, tool_command(:git), commit_args(:git, "base: git repo"), repo_path, env, runner)
      end

    {steps, _} =
      maybe_run_sapling_on_git_repo(
        steps,
        git_status,
        repo_path,
        requested,
        available,
        runner
      )

    status = compute_status(steps)
    compatibility = compatibility_status(steps, [:sapling_status, :sapling_log])

    {%{
       id: :git_repo_with_sapling,
       description: "Git repo opened with Sapling",
       repo_path: repo_path,
       status: status,
       compatibility: compatibility,
       steps: steps
     }, repo_path}
  end

  defp run_sapling_repo(requested, available, tmp_root, runner, fs) do
    repo_path = Path.join(tmp_root, "sapling_interop_sapling_#{System.unique_integer([:positive])}")

    requested_sapling = MapSet.member?(requested, :sapling)
    available_sapling = MapSet.member?(available, :sapling)

    {steps, sapling_status} =
      cond do
        not requested_sapling ->
          {skip_steps_for_sapling_repo([], "tool not requested: sapling"), :skipped}

        not available_sapling ->
          {skip_steps_for_sapling_repo([], "missing tool: sapling"), :skipped}

        true ->
          fs.mkdir_p!(repo_path)
          env = tool_env(:sapling)

          {[], :ok}
          |> run_step(:sapling_init_git, tool_command(:sapling), ["init", "--git"], repo_path, env, runner)
          |> run_step(:sapling_config, tool_command(:sapling), identity_args(:sapling), repo_path, env, runner)
          |> write_readme(repo_path, fs)
          |> run_step(:sapling_add, tool_command(:sapling), add_args(:sapling), repo_path, env, runner)
          |> run_step(
            :sapling_commit,
            tool_command(:sapling),
            commit_args(:sapling, "base: sapling repo"),
            repo_path,
            env,
            runner
          )
      end

    {steps, _} =
      maybe_run_git_on_sapling_repo(
        steps,
        sapling_status,
        repo_path,
        requested,
        available,
        runner
      )

    status = compute_status(steps)
    compatibility = compatibility_status(steps, [:git_status, :git_log])

    {%{
       id: :sapling_repo_with_git,
       description: "Sapling git-backed repo opened with Git",
       repo_path: repo_path,
       status: status,
       compatibility: compatibility,
       steps: steps
     }, repo_path}
  end

  defp maybe_run_sapling_on_git_repo(steps, git_status, repo_path, requested, available, runner) do
    requested_sapling = MapSet.member?(requested, :sapling)
    available_sapling = MapSet.member?(available, :sapling)

    cond do
      not requested_sapling ->
        steps =
          steps
          |> skip_step(:sapling_status, tool_command(:sapling), ["status"], "tool not requested: sapling")
          |> skip_step(:sapling_log, tool_command(:sapling), ["log", "-l", "5"], "tool not requested: sapling")

        {steps, git_status}

      not available_sapling ->
        steps =
          steps
          |> skip_step(:sapling_status, tool_command(:sapling), ["status"], "missing tool: sapling")
          |> skip_step(:sapling_log, tool_command(:sapling), ["log", "-l", "5"], "missing tool: sapling")

        {steps, git_status}

      git_status != :ok ->
        steps =
          steps
          |> skip_step(:sapling_status, tool_command(:sapling), ["status"], "git repo not ready")
          |> skip_step(:sapling_log, tool_command(:sapling), ["log", "-l", "5"], "git repo not ready")

        {steps, git_status}

      true ->
        env = tool_env(:sapling)

        {steps, :ok}
        |> run_step(:sapling_status, tool_command(:sapling), ["status"], repo_path, env, runner)
        |> run_step(:sapling_log, tool_command(:sapling), ["log", "-l", "5"], repo_path, env, runner)
    end
  end

  defp maybe_run_git_on_sapling_repo(steps, sapling_status, repo_path, requested, available, runner) do
    requested_git = MapSet.member?(requested, :git)
    available_git = MapSet.member?(available, :git)

    cond do
      not requested_git ->
        steps =
          steps
          |> skip_step(:git_status, tool_command(:git), ["status", "--short"], "tool not requested: git")
          |> skip_step(:git_log, tool_command(:git), ["log", "-n", "5", "--oneline"], "tool not requested: git")

        {steps, sapling_status}

      not available_git ->
        steps =
          steps
          |> skip_step(:git_status, tool_command(:git), ["status", "--short"], "missing tool: git")
          |> skip_step(:git_log, tool_command(:git), ["log", "-n", "5", "--oneline"], "missing tool: git")

        {steps, sapling_status}

      sapling_status != :ok ->
        steps =
          steps
          |> skip_step(:git_status, tool_command(:git), ["status", "--short"], "sapling repo not ready")
          |> skip_step(:git_log, tool_command(:git), ["log", "-n", "5", "--oneline"], "sapling repo not ready")

        {steps, sapling_status}

      true ->
        env = tool_env(:git)

        {steps, :ok}
        |> run_step(:git_status, tool_command(:git), ["status", "--short"], repo_path, env, runner)
        |> run_step(:git_log, tool_command(:git), ["log", "-n", "5", "--oneline"], repo_path, env, runner)
    end
  end

  defp skip_steps_for_git_repo(steps, reason) do
    steps
    |> skip_step(:git_init, tool_command(:git), ["init"], reason)
    |> skip_step(:git_config, tool_command(:git), identity_args(:git), reason)
    |> skip_step(:git_add, tool_command(:git), add_args(:git), reason)
    |> skip_step(:git_commit, tool_command(:git), commit_args(:git, "base: git repo"), reason)
  end

  defp skip_steps_for_sapling_repo(steps, reason) do
    steps
    |> skip_step(:sapling_init_git, tool_command(:sapling), ["init", "--git"], reason)
    |> skip_step(:sapling_config, tool_command(:sapling), identity_args(:sapling), reason)
    |> skip_step(:sapling_add, tool_command(:sapling), add_args(:sapling), reason)
    |> skip_step(:sapling_commit, tool_command(:sapling), commit_args(:sapling, "base: sapling repo"), reason)
  end

  defp skip_step(steps, label, cmd, args, reason) do
    step = %{
      label: label,
      command: cmd,
      args: args,
      status: :skipped,
      output: "skipped (#{reason})"
    }

    steps ++ [step]
  end

  defp write_readme({steps, :error}, _repo_path, _fs), do: {steps, :error}

  defp write_readme({steps, :ok}, repo_path, fs) do
    fs.write!(Path.join(repo_path, "README.md"), "# Interop\n\nBase commit.\n")
    {steps, :ok}
  end

  defp run_step({steps, :error}, _label, _cmd, _args, _repo_path, _env, _runner), do: {steps, :error}

  defp run_step({steps, :ok}, label, cmd, args, repo_path, env, runner) do
    {output, status} = runner.(cmd, args, command_opts(repo_path, env))

    step = %{
      label: label,
      command: cmd,
      args: args,
      status: status,
      output: to_string(output)
    }

    next_status = if status == 0, do: :ok, else: :error
    {steps ++ [step], next_status}
  end

  defp command_opts(repo_path, []), do: [cd: repo_path]
  defp command_opts(repo_path, env), do: [cd: repo_path, env: env]

  defp compute_status([]), do: :skipped

  defp compute_status(steps) do
    statuses = Enum.map(steps, & &1.status)

    cond do
      Enum.any?(statuses, &is_integer(&1) and &1 != 0) -> :error
      Enum.all?(statuses, &(&1 == :skipped)) -> :skipped
      true -> :ok
    end
  end

  defp scenario_lines do
    [
      "- Git repo opened with Sapling (Sapling reads Git metadata)",
      "- Sapling git-backed repo opened with Git (Git reads Sapling commits)"
    ]
  end

  defp summary_lines([]), do: ["(no scenarios run)"]

  defp summary_lines(results) do
    Enum.map(results, fn scenario ->
      compatibility = Map.get(scenario, :compatibility) || compatibility_label(scenario.steps || [])
      status = Map.get(scenario, :status, :unknown)
      "#{scenario.description}: #{compatibility} (status #{status})"
    end)
  end

  defp format_scenario(%{description: description, repo_path: repo_path, status: status, steps: steps} = scenario) do
    compatibility = Map.get(scenario, :compatibility) || compatibility_label(steps)

    [
      "### #{description}",
      "Repo path: `#{repo_path || "(not created)"}`",
      "Status: #{status}",
      "Compatibility: #{compatibility}",
      ""
    ] ++ format_steps(steps) ++ [""]
  end

  defp format_steps([]), do: ["(no steps recorded)"]

  defp format_steps(steps) do
    Enum.flat_map(steps, fn step ->
      command =
        case step.args do
          [] -> step.command
          _ -> "#{step.command} #{Enum.join(step.args, " ")}"
        end

      [
        "#{step.label}: `#{command}` (status #{step.status})",
        "Output:",
        "```",
        format_output(step.output),
        "```",
        ""
      ]
    end)
  end

  defp format_output(output) do
    output
    |> to_string()
    |> String.trim_trailing()
    |> case do
      "" -> "(no output)"
      value -> value
    end
  end

  defp compatibility_status(steps, labels) do
    statuses =
      Enum.map(labels, fn label ->
        case Enum.find(steps, &(&1.label == label)) do
          nil -> nil
          step -> step.status
        end
      end)

    cond do
      Enum.all?(statuses, &(&1 == 0)) -> :ok
      Enum.any?(statuses, &(&1 == :skipped or is_nil(&1))) -> :blocked
      Enum.any?(statuses, &is_integer(&1) and &1 != 0) -> :error
      true -> :unknown
    end
  end

  defp compatibility_label(steps) do
    labels =
      case Enum.find(steps, &(&1.label in [:sapling_status, :sapling_log])) do
        nil -> [:git_status, :git_log]
        _step -> [:sapling_status, :sapling_log]
      end

    compatibility_status(steps, labels)
  end

  defp missing_tools_line([]), do: []
  defp missing_tools_line(missing_tools), do: ["Missing tools: `#{Enum.join(missing_tools, ", ")}`"]

  defp normalize_tool(:git), do: :git
  defp normalize_tool(:sapling), do: :sapling
  defp normalize_tool("git"), do: :git
  defp normalize_tool("sapling"), do: :sapling
  defp normalize_tool("sl"), do: :sapling
  defp normalize_tool(_), do: nil

  defp tool_command(:git), do: "git"
  defp tool_command(:sapling), do: "sl"

  defp tool_env(:git) do
    [
      {"GIT_AUTHOR_NAME", "Micelio Agent"},
      {"GIT_AUTHOR_EMAIL", "agent@micelio.dev"},
      {"GIT_COMMITTER_NAME", "Micelio Agent"},
      {"GIT_COMMITTER_EMAIL", "agent@micelio.dev"}
    ]
  end

  defp tool_env(:sapling) do
    [{"HGUSER", "Micelio Agent <agent@micelio.dev>"}]
  end

  defp identity_args(:git), do: ["config", "user.name", "Micelio Agent"]
  defp identity_args(:sapling), do: ["config", "ui.username", "Micelio Agent <agent@micelio.dev>"]

  defp add_args(:git), do: ["add", "-A"]
  defp add_args(:sapling), do: ["add", "."]

  defp commit_args(:git, message), do: ["commit", "-m", message]
  defp commit_args(:sapling, message), do: ["commit", "-m", message]
end
